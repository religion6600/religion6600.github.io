[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "6600 Final Project",
    "section": "",
    "text": "hello world!"
  },
  {
    "objectID": "code/clustering.html",
    "href": "code/clustering.html",
    "title": "Clustering Analysis",
    "section": "",
    "text": "import pandas as pd\nfrom sklearn.cluster import KMeans\nfrom sklearn.preprocessing import StandardScaler\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import silhouette_score\ndf = pd.read_csv(\"../data/religion_data.csv\")\ndf.head()\n\n\n\n\n\n\n\n\nP_SUID\nYEAR_FROM_CODATE\nHAPPY\nSATIS_A\nSATIS_B\nCHNG_A\nCHNG_B\nCHNG_C\nDIVRELPOP\nDIVRACPOP\n...\nMOVED\nREG\nPARTY\nIDEO\nHH1REC\nINTFREQ\nINC_SDT1\nGENDER\nFERTREC\nWEIGHT\n\n\n\n\n0\n10000040\n2023\n1\n2\n2\n2\n3\n2\n2\n3\n...\n1\n1\n1\n1\n3\n2\n2\n2\n1\n4399.707781\n\n\n1\n10000060\n2023\n1\n2\n1\n1\n1\n1\n1\n1\n...\n2\n1\n2\n5\n3\n2\n7\n2\n2\n6693.424549\n\n\n2\n10000140\n2024\n2\n2\n3\n3\n1\n1\n1\n1\n...\n1\n1\n3\n3\n2\n1\n7\n2\n0\n3080.916226\n\n\n3\n10000150\n2023\n3\n3\n3\n2\n1\n2\n3\n1\n...\n2\n1\n1\n3\n2\n2\n99\n2\n2\n5470.685158\n\n\n4\n10000160\n2023\n3\n1\n1\n3\n1\n2\n1\n1\n...\n2\n1\n2\n4\n2\n1\n5\n2\n2\n2474.921511\n\n\n\n\n5 rows × 107 columns"
  },
  {
    "objectID": "code/clustering.html#selecting-relevant-features",
    "href": "code/clustering.html#selecting-relevant-features",
    "title": "Clustering Analysis",
    "section": "Selecting Relevant Features",
    "text": "Selecting Relevant Features\n\nfeatures = [\n    'CHNG_C',        # Views on transgender people\n    'DIVRELPOP',     # Diversity of religion in society\n    'DIVRACPOP',     # Diversity of race in society\n    'QB2A', 'QB2C', 'QB2D',  # Values: homosexuality, environment, right/wrong\n    'OPENIDEN', 'POORASSIST', 'GOVSIZE1',\n    'ABRTLGL', 'GAYMARR',  # Abortion & gay marriage\n    'CLIM1A', 'EVOL',      # Climate & evolution\n    'GUIDE_B', 'GUIDE_C', 'GUIDE_D',  # Logic, science, common sense\n    'MARITAL', 'CHILDREN', 'GENDER', 'BIRTHDECADE',\n    'EDUCREC', 'EMPLSIT', 'USGEN', 'REG', 'PARTY', 'IDEO',\n    'HH1REC', 'INTFREQ', 'INC_SDT1'\n]"
  },
  {
    "objectID": "code/clustering.html#k-means",
    "href": "code/clustering.html#k-means",
    "title": "Clustering Analysis",
    "section": "K-Means",
    "text": "K-Means\nWe applied KMeans clustering to a set of respondents using a range of non-religious socio-political and demographic features, including views on gender and sexuality, political ideology, education, income, attitudes toward science and government, and more. The goal was to determine whether individuals naturally group into distinct sociocultural profiles — and to assess how those profiles correspond (if at all) with religious tradition (RELTRAD).\n\nOptimal # of CLusters\nFirst we attempted to find optimalk with elbow method but it’s not exactly clear, possible k=5.\n\nX = df[features].dropna()  # Drop rows with missing values\n\n# Keep original indices to map back religion\ndf_clean = df.loc[X.index]\n\n# Scale features\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\n\n# Elbow Method to choose k\nwcss = []\nfor i in range(2, 10):\n    kmeans = KMeans(n_clusters=i, random_state=42)\n    kmeans.fit(X_scaled)\n    wcss.append(kmeans.inertia_)\n\nplt.plot(range(2, 10), wcss, marker='o')\nplt.title(\"Elbow Method for Optimal k\")\nplt.xlabel(\"Number of clusters\")\nplt.ylabel(\"WCSS\")\nplt.show()\n\n\n\n\n\n\n\n\nSilhouette Score demonstrates that optimal k=2, but there are more than two religions so this may be limiting - we won’t be able to map religions directly but we can possibly see traditionalist religions vs progressive.\n\n\nK = 2\n\nsilhouette_scores = []\nK_range = range(2, 10)\n\nfor k in K_range:\n    kmeans = KMeans(n_clusters=k, random_state=42)\n    labels = kmeans.fit_predict(X_scaled)\n    score = silhouette_score(X_scaled, labels)\n    silhouette_scores.append(score)\n\nplt.figure(figsize=(8, 5))\nplt.plot(K_range, silhouette_scores, marker='o')\nplt.title('Silhouette Score for different k')\nplt.xlabel('Number of clusters (k)')\nplt.ylabel('Silhouette Score')\nplt.xticks(K_range)\nplt.show()\n\n\n\n\n\n\n\n\n\nfrom sklearn.cluster import KMeans\n\nkmeans = KMeans(n_clusters=2, random_state=42)\ndf_clean['cluster'] = kmeans.fit_predict(X_scaled)\n\n\nfrom sklearn.decomposition import PCA\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X_scaled)\ndf_clean['pca1'] = X_pca[:, 0]\ndf_clean['pca2'] = X_pca[:, 1]\n\nplt.figure(figsize=(8, 6))\nsns.scatterplot(data=df_clean, x='pca1', y='pca2', hue='cluster', palette='Set2')\nplt.title(\"KMeans Clustering with k=2 (PCA-reduced)\")\nplt.show()\n\n\n\n\n\n\n\n\n\npd.crosstab(df_clean['cluster'], df_clean['RELTRAD'])\n\n\n\n\n\n\n\nRELTRAD\n1100\n1200\n1300\n10000\n20000\n30000\n40001\n40002\n50000\n60000\n70000\n80000\n90001\n90002\n100000\n900000\n\n\ncluster\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n0\n7791\n5023\n1342\n6564\n545\n209\n88\n210\n821\n250\n336\n219\n93\n725\n10317\n311\n\n\n1\n507\n310\n126\n394\n20\n16\n25\n16\n29\n23\n12\n28\n6\n36\n412\n104\n\n\n\n\n\n\n\nCluster profiles by feature (Standardized Average)\n\ncluster_profiles = df_clean.groupby('cluster')[features].mean().T\ncluster_profiles.columns = [f'Cluster {i}' for i in cluster_profiles.columns]\ncluster_profiles.plot(kind='bar', figsize=(16, 6), colormap='Set2')\nplt.title(\"Cluster Feature Averages (k=2)\")\nplt.ylabel(\"Mean value (standardized scale)\")\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nCluster 0: Traditionalist-Conservative Profile - Lower support for abortion access, gay marriage, and transgender rights - Lower scores on science-based decision-making and belief in evolution - More traditional views on family, gender, and government roles - Slightly lower educational attainment and income - Politically more conservative on average\nCluster 1: Progressive-Secular Profile - Significantly higher support for LGBTQ+ rights, abortion, and climate action - Stronger emphasis on scientific reasoning, logic, and evolution acceptance - Higher average education and income levels - More likely to be politically liberal or Democratic - More urban and socially inclusive profile\n*RELTRAD Distribution per Cluster\n\nreltrad_labels = {\n    1100: \"Evangelical Protestant\",\n    1200: \"Mainline Protestant\",\n    1300: \"Historically Black Protestant\",\n    10000: \"Catholic\",\n    20000: \"Mormon\",\n    30000: \"Orthodox Christian\",\n    40001: \"Jehovah's Witness\",\n    40002: \"Other Christian\",\n    50000: \"Jewish\",\n    60000: \"Muslim\",\n    70000: \"Buddhist\",\n    80000: \"Hindu\",\n    90001: \"Other World Religions\",\n    90002: \"Other Faiths\",\n    100000: \"Religiously Unaffiliated\",\n    900000: \"Don't know/refused\"\n}\n\n\ndf_clean['RELTRAD_label'] = df_clean['RELTRAD'].map(reltrad_labels)\nct = pd.crosstab(df_clean['cluster'], df_clean['RELTRAD_label'], normalize='index')\n\nct.plot(kind='bar', stacked=True, figsize=(14, 7), colormap='tab20')\nplt.title(\"RELTRAD Distribution by Cluster (k=2)\")\nplt.xlabel(\"Cluster\")\nplt.ylabel(\"Proportion\")\nplt.legend(title=\"Religious Tradition\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nConclusions:\n\nMost major religious traditions (Evangelical, Catholic, Mainline Protestant) are evenly distributed across clusters.\nThis suggests that religious identity alone does not strongly predict worldview orientation.\nFor example, ~23% of both clusters are Evangelical Protestants, despite vast differences in cultural values.\nThe Religiously Unaffiliated group is overrepresented in Cluster 0, the “Traditionalist” cluster.\nThis is a bit counterintuitive — and likely reflects the diversity within the unaffiliated group, which includes atheists, agnostics, spiritual-but-not-religious individuals, and culturally non-religious people with differing values.\nCluster 1 includes relatively higher proportions of religious minorities and smaller groups (e.g., Hindu, Muslim, Buddhist), but numbers are small in both.\nPeople of the same religion — particularly large groups like Evangelicals, Catholics, and the Unaffiliated — are found in both clusters, revealing intra-religious ideological diversity."
  },
  {
    "objectID": "code/clustering.html#k-5",
    "href": "code/clustering.html#k-5",
    "title": "Clustering Analysis",
    "section": "K = 5",
    "text": "K = 5\nNow we will use k=5 to capture more nuanced sociopoltiical differences and possible capture differences between the two subgroups.\n\nkmeans_5 = KMeans(n_clusters=5, random_state=42)\ndf_clean['cluster_5'] = kmeans_5.fit_predict(X_scaled)\n\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X_scaled)\ndf_clean['pca1'] = X_pca[:, 0]\ndf_clean['pca2'] = X_pca[:, 1]\n\nplt.figure(figsize=(8, 6))\nsns.scatterplot(data=df_clean, x='pca1', y='pca2', hue='cluster_5', palette='Set2')\nplt.title(\"KMeans Clustering with k=5 (PCA-reduced)\")\nplt.legend(title='Cluster')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nCluster profiles by feature (Standardized Average)\n\ncluster_profiles_5 = df_clean.groupby('cluster_5')[features].mean().T\ncluster_profiles_5.columns = [f'Cluster {i}' for i in cluster_profiles_5.columns]\ncluster_profiles_5.plot(kind='bar', figsize=(16, 6), colormap='Set2')\nplt.title(\"Cluster Feature Averages (k=5)\")\nplt.ylabel(\"Mean value (standardized scale)\")\nplt.xticks(rotation=45, ha='right')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nCluster 0 (Green-teal)\nModerate baseline across most features, with: - Low to moderate support for LGBTQ+ rights (CHNG_C), gay marriage (GAYMARR), and abortion access (ABRTLGL) - Lower belief in science-based reasoning (EVOL, GUIDE_D), but not the lowest - Slightly lower education (EDUCREC) and income (INC_SDT1) - Lower openness (OPENIDEN) and acceptance of diversity (DIVRELPOP, DIVRACPOP)\nThis cluster reflects a modestly traditional group with relatively lower political or social engagement. They may represent lower-income individuals with mixed or centrist values.\n\nCluster 1 (Blue): Strongly progressive values, including:\n\nHigh support for LGBTQ+ rights, abortion, and social inclusion\nElevated belief in evolution and use of science in decision-making (EVOL, GUIDE_B, GUIDE_D)\nHigher liberal political orientation (IDEO, PARTY)\nHigh education and income levels (EDUCREC, INC_SDT1)\nLow support for limited government (GOVSIZE1), possibly favoring social programs\n\nThis cluster appears to represent a progressive, well-educated population with a high level of civic engagement and trust in science.\nCluster 2 (Light Green): Defined by one dominant outlier:\n\nCLIM1A (concern about climate change) is extremely high—almost 100 on standardized scale\nFairly moderate or slightly progressive values across the board\n\nThis may represent a group strongly motivated by environmental concern, though the extreme spike in one feature could also reflect a data or scaling artifact.\nCluster 3 (Orange): Marked by very high civic and socioeconomic engagement\n\nStrong scores on political participation (PARTY, IDEO), education (EDUCREC), income (INC_SDT1), internet use (INTFREQ), and household size (HH1REC)\nAlso high on science-related features (EVOL, GUIDE_B/C/D)\nHigh support for LGBTQ+ rights, abortion, and openness\n\nThis cluster likely represents high-income, highly educated individuals with strong progressive values. Potentially urban, young professionals or politically active elites.\nCluster 4 (Gray): Distinct for strong traditional and conservative indicators.\n\nPreference for smaller government (GOVSIZE1)\nLow openness (OPENIDEN), low scientific reliance (GUIDE_D), and low diversity tolerance\nTraditional family values: higher scores on CHILDREN, GENDER, MARITAL\nLower political liberalism (IDEO, PARTY)\n\nThis cluster likely reflects a socially conservative population with strong emphasis on family, tradition, and limited government. Trust in science and progressive norms is relatively low.\n*RELTRAD Distribution per Cluster\n\n# Optional: drop \"refused\" or unclear categories\nexcluded = [\"Don't know/refused\", \"Other Christian\", \"Other World Religions\", \"Other Faiths\"]\ndf_clean = df_clean[~df_clean['RELTRAD_label'].isin(excluded)]\n\n# RELTRAD by cluster\nct_5 = pd.crosstab(df_clean['cluster_5'], df_clean['RELTRAD_label'], normalize='index')\nct_5.plot(kind='bar', stacked=True, figsize=(14, 7), colormap='tab20')\nplt.title(\"RELTRAD Distribution by Cluster (k=5)\")\nplt.xlabel(\"Cluster\")\nplt.ylabel(\"Proportion\")\nplt.legend(title=\"Religious Tradition\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nCluster 0: Mixed religious background with a high share of unaffiliated. Likely a moderately secular group.\nCluster 1: Heavily Evangelical Protestant. Strongly religious and likely more traditional.\nCluster 2: Balanced mix — Catholic, Protestant, and unaffiliated all present. Moderate religious diversity.\nCluster 3: Mostly unaffiliated. Reflects a highly secular, progressive group.\nCluster 4: Dominated by Evangelical Protestants, with some Catholic and Mainline. Likely socially conservative.\n\nIn short, Clusters 1 and 4 skew religious/traditional, while Cluster 3 is clearly secular. Clusters 0 and 2 fall somewhere in between."
  },
  {
    "objectID": "code/QDA.html",
    "href": "code/QDA.html",
    "title": "QDA",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, classification_report, RocCurveDisplay\nfrom sklearn.preprocessing import StandardScaler, label_binarize\nfrom sklearn.metrics import roc_auc_score, accuracy_score\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import compute_class_weight\nfrom sklearn.feature_selection import VarianceThreshold\nfrom imblearn.over_sampling import SMOTE\nimport warnings\n\n# dealing with an SkLearn deprecated warning\nwarnings.filterwarnings(\"ignore\", category=FutureWarning, module=\"sklearn\")\n\n# reading in data\nreligion = pd.read_csv(\"../data/religion_data_no99.csv\")\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Protestant',\n    10000: 'Catholic',\n    20000: 'Mormon',\n    30000: 'Orthodox Christian',\n    40001: 'Jehovahs Witness',\n    40002: 'Other Christian',\n    50000: 'Jewish',\n    60000: 'Muslim',\n    70000: 'Buddhist',\n    80000: 'Hindu',\n    90001: 'Other world Religions',\n    90002: 'Other faiths',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nProtestant            8723\nUnaffiliated          7355\nCatholic              4074\nJewish                 521\nMormon                 362\nBuddhist               232\nMuslim                 167\nHindu                  164\nOrthodox Christian     132\nJehovahs Witness        34\nName: count, dtype: int64\n(21764,)\n(21764, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(13928, 100)\n(13928,)\n\nVALIDATION\n(3483, 100)\n(3483,)\n\nTEST\n(4353, 100)\n(4353,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.7203560149296584\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n                    precision    recall  f1-score   support\n\n          Buddhist       0.21      0.17      0.19        48\n          Catholic       0.58      0.67      0.62       824\n             Hindu       0.64      0.38      0.47        37\n  Jehovahs Witness       0.00      0.00      0.00         9\n            Jewish       0.23      0.62      0.33        98\n            Mormon       0.14      0.67      0.24        58\n            Muslim       0.47      0.42      0.44        19\nOrthodox Christian       0.05      0.05      0.05        20\n        Protestant       0.82      0.63      0.71      1752\n      Unaffiliated       0.94      0.90      0.92      1488\n\n          accuracy                           0.72      4353\n         macro avg       0.41      0.45      0.40      4353\n      weighted avg       0.78      0.72      0.74      4353\n\n0.7176659774867907\n-----------------------\nCONFUSION MATRIX:\n[[   8    5    1    0    6    1    2    0    2   23]\n [   1  548    3    0   45   41    2    4  163   17]\n [   2    3   14    0    2    0    3    0    0   13]\n [   0    2    0    0    0    0    0    0    7    0]\n [   2   12    0    0   61    0    0    0   11   12]\n [   0    2    0    0    1   39    0    0   16    0]\n [   0    2    0    0    1    0    8    1    4    3]\n [   1    7    0    0    1    0    0    1    9    1]\n [   4  352    2    0   75  190    1   15 1102   11]\n [  20   20    2    0   77    1    1    1   23 1343]]\n-----------------------\nROC CURVES:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# reading in data\nreligion = pd.read_csv(\"../data/religion_full_currel.csv\")\n\n\n\n\n\n\n\nCode\n# visualizing imbalance\ny = religion['CURREL']\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# dropping refused \nreligion = religion[religion['CURREL'] != 900000]\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Christian',\n    10000: 'Christian',\n    20000: 'Christian',\n    30000: 'Christian',\n    40001: 'Christian',\n    40002: 'Christian',\n    50000: 'Non-Christian',\n    60000: 'Non-Christian',\n    70000: 'Non-Christian',\n    80000: 'Non-Christian',\n    90001: 'Non-Christian',\n    90002: 'Non-Christian',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nChristian        13442\nUnaffiliated      7355\nNon-Christian     1651\nName: count, dtype: int64\n(22448,)\n(22448, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(14366, 100)\n(14366,)\n\nVALIDATION\n(3592, 100)\n(3592,)\n\nTEST\n(4490, 100)\n(4490,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.8933741648106904\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n               precision    recall  f1-score   support\n\n    Christian       0.97      0.92      0.95      2724\nNon-Christian       0.38      0.57      0.46       317\n Unaffiliated       0.91      0.89      0.90      1449\n\n     accuracy                           0.89      4490\n    macro avg       0.75      0.80      0.77      4490\n weighted avg       0.91      0.89      0.90      4490\n\n0.889532293986637\n-----------------------\nCONFUSION MATRIX:\n[[2519  175   30]\n [  37  181   99]\n [  36  119 1294]]\n-----------------------\nROC CURVES:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# reading in data\nreligion = pd.read_csv(\"../data/religion_full_currel.csv\")\n\n\n\n\n\n\n\nCode\n# visualizing imbalance\ny = religion['CURREL']\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# dropping refused \nreligion = religion[religion['CURREL'] != 900000]\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Protestant',\n    10000: 'Catholic',\n    20000: 'Mormon',\n    30000: 'Christian',\n    40001: 'Christian',\n    40002: 'Christian',\n    50000: 'Jewish',\n    60000: 'Muslim',\n    70000: 'Other Religion',\n    80000: 'Other Religion',\n    90001: 'Other Religion',\n    90002: 'Other Religion',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nProtestant        8723\nUnaffiliated      7355\nCatholic          4074\nOther Religion     963\nJewish             521\nMormon             362\nChristian          283\nMuslim             167\nName: count, dtype: int64\n(22448,)\n(22448, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(14366, 100)\n(14366,)\n\nVALIDATION\n(3592, 100)\n(3592,)\n\nTEST\n(4490, 100)\n(4490,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.6909799554565702\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n                precision    recall  f1-score   support\n\n      Catholic       0.56      0.64      0.60       815\n     Christian       0.14      0.16      0.15        63\n        Jewish       0.23      0.50      0.32       107\n        Mormon       0.18      0.65      0.29        69\n        Muslim       0.53      0.22      0.31        37\nOther Religion       0.29      0.48      0.36       173\n    Protestant       0.83      0.65      0.73      1777\n  Unaffiliated       0.91      0.82      0.86      1449\n\n      accuracy                           0.68      4490\n     macro avg       0.46      0.52      0.45      4490\n  weighted avg       0.75      0.68      0.71      4490\n\n0.6841870824053452\n-----------------------\nCONFUSION MATRIX:\n[[ 525   18   43   39    0   13  166   11]\n [  14   10    4    1    1    8   22    3]\n [  18    1   54    1    0    5    7   21]\n [  12    0    0   45    0    0   11    1]\n [   6    2    1    0    8   12    6    2]\n [   5    1    8    0    4   83    7   65]\n [ 341   31   71  159    1    6 1160    8]\n [  19    8   51    0    1  159   24 1187]]\n-----------------------\nROC CURVES:"
  },
  {
    "objectID": "code/QDA.html#all-currel-categories",
    "href": "code/QDA.html#all-currel-categories",
    "title": "QDA",
    "section": "",
    "text": "Code\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis\nfrom sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, classification_report, RocCurveDisplay\nfrom sklearn.preprocessing import StandardScaler, label_binarize\nfrom sklearn.metrics import roc_auc_score, accuracy_score\nimport matplotlib.pyplot as plt\nfrom sklearn.utils import compute_class_weight\nfrom sklearn.feature_selection import VarianceThreshold\nfrom imblearn.over_sampling import SMOTE\nimport warnings\n\n# dealing with an SkLearn deprecated warning\nwarnings.filterwarnings(\"ignore\", category=FutureWarning, module=\"sklearn\")\n\n# reading in data\nreligion = pd.read_csv(\"../data/religion_data_no99.csv\")\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Protestant',\n    10000: 'Catholic',\n    20000: 'Mormon',\n    30000: 'Orthodox Christian',\n    40001: 'Jehovahs Witness',\n    40002: 'Other Christian',\n    50000: 'Jewish',\n    60000: 'Muslim',\n    70000: 'Buddhist',\n    80000: 'Hindu',\n    90001: 'Other world Religions',\n    90002: 'Other faiths',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nProtestant            8723\nUnaffiliated          7355\nCatholic              4074\nJewish                 521\nMormon                 362\nBuddhist               232\nMuslim                 167\nHindu                  164\nOrthodox Christian     132\nJehovahs Witness        34\nName: count, dtype: int64\n(21764,)\n(21764, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(13928, 100)\n(13928,)\n\nVALIDATION\n(3483, 100)\n(3483,)\n\nTEST\n(4353, 100)\n(4353,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.7203560149296584\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n                    precision    recall  f1-score   support\n\n          Buddhist       0.21      0.17      0.19        48\n          Catholic       0.58      0.67      0.62       824\n             Hindu       0.64      0.38      0.47        37\n  Jehovahs Witness       0.00      0.00      0.00         9\n            Jewish       0.23      0.62      0.33        98\n            Mormon       0.14      0.67      0.24        58\n            Muslim       0.47      0.42      0.44        19\nOrthodox Christian       0.05      0.05      0.05        20\n        Protestant       0.82      0.63      0.71      1752\n      Unaffiliated       0.94      0.90      0.92      1488\n\n          accuracy                           0.72      4353\n         macro avg       0.41      0.45      0.40      4353\n      weighted avg       0.78      0.72      0.74      4353\n\n0.7176659774867907\n-----------------------\nCONFUSION MATRIX:\n[[   8    5    1    0    6    1    2    0    2   23]\n [   1  548    3    0   45   41    2    4  163   17]\n [   2    3   14    0    2    0    3    0    0   13]\n [   0    2    0    0    0    0    0    0    7    0]\n [   2   12    0    0   61    0    0    0   11   12]\n [   0    2    0    0    1   39    0    0   16    0]\n [   0    2    0    0    1    0    8    1    4    3]\n [   1    7    0    0    1    0    0    1    9    1]\n [   4  352    2    0   75  190    1   15 1102   11]\n [  20   20    2    0   77    1    1    1   23 1343]]\n-----------------------\nROC CURVES:"
  },
  {
    "objectID": "code/QDA.html#christian-vs-non-christian-vs-unaffiliated",
    "href": "code/QDA.html#christian-vs-non-christian-vs-unaffiliated",
    "title": "QDA",
    "section": "",
    "text": "Code\n# reading in data\nreligion = pd.read_csv(\"../data/religion_full_currel.csv\")\n\n\n\n\n\n\n\nCode\n# visualizing imbalance\ny = religion['CURREL']\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# dropping refused \nreligion = religion[religion['CURREL'] != 900000]\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Christian',\n    10000: 'Christian',\n    20000: 'Christian',\n    30000: 'Christian',\n    40001: 'Christian',\n    40002: 'Christian',\n    50000: 'Non-Christian',\n    60000: 'Non-Christian',\n    70000: 'Non-Christian',\n    80000: 'Non-Christian',\n    90001: 'Non-Christian',\n    90002: 'Non-Christian',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nChristian        13442\nUnaffiliated      7355\nNon-Christian     1651\nName: count, dtype: int64\n(22448,)\n(22448, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(14366, 100)\n(14366,)\n\nVALIDATION\n(3592, 100)\n(3592,)\n\nTEST\n(4490, 100)\n(4490,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.8933741648106904\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n               precision    recall  f1-score   support\n\n    Christian       0.97      0.92      0.95      2724\nNon-Christian       0.38      0.57      0.46       317\n Unaffiliated       0.91      0.89      0.90      1449\n\n     accuracy                           0.89      4490\n    macro avg       0.75      0.80      0.77      4490\n weighted avg       0.91      0.89      0.90      4490\n\n0.889532293986637\n-----------------------\nCONFUSION MATRIX:\n[[2519  175   30]\n [  37  181   99]\n [  36  119 1294]]\n-----------------------\nROC CURVES:"
  },
  {
    "objectID": "code/QDA.html#protestant-catholic-mormon-christian-jewish-muslim-other-unaffaliated",
    "href": "code/QDA.html#protestant-catholic-mormon-christian-jewish-muslim-other-unaffaliated",
    "title": "QDA",
    "section": "",
    "text": "Code\n# reading in data\nreligion = pd.read_csv(\"../data/religion_full_currel.csv\")\n\n\n\n\n\n\n\nCode\n# visualizing imbalance\ny = religion['CURREL']\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# dropping refused \nreligion = religion[religion['CURREL'] != 900000]\n\n# Christian, non-christian, unaffiliated\ngrouping_map = {\n    1000: 'Protestant',\n    10000: 'Catholic',\n    20000: 'Mormon',\n    30000: 'Christian',\n    40001: 'Christian',\n    40002: 'Christian',\n    50000: 'Jewish',\n    60000: 'Muslim',\n    70000: 'Other Religion',\n    80000: 'Other Religion',\n    90001: 'Other Religion',\n    90002: 'Other Religion',\n    100000: 'Unaffiliated'\n}\n\nreligion['CURREL_NEW'] = religion['CURREL'].map(grouping_map)\n\n\n\n\n\n\n\n\n\n\n\nCode\n# getting the x and y variables\nX_int = religion.drop(columns=['RELTRAD', 'CURREL_NEW'])\n\n# take currel\ny = religion['CURREL_NEW']\n\n# drop some rows for y\nprint(y.value_counts())\n\n# checking shapes\nprint(y.shape)\nprint(X_int.shape)\n\n\nCURREL_NEW\nProtestant        8723\nUnaffiliated      7355\nCatholic          4074\nOther Religion     963\nJewish             521\nMormon             362\nChristian          283\nMuslim             167\nName: count, dtype: int64\n(22448,)\n(22448, 100)\n\n\n\n\n\n\n\nCode\n# scaling X value\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_int)\n\n# split data into test, train, validation\nX_tmp, X_test, y_tmp, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=6600)\nX_train, X_val, y_train, y_val = train_test_split(X_tmp, y_tmp, test_size=0.2, random_state=6600)\n\n# print\nprint(\"\\nTRAIN\")\nprint(X_train.shape)\nprint(y_train.shape)\n\nprint(\"\\nVALIDATION\")\nprint(X_val.shape)\nprint(y_val.shape)\n\nprint(\"\\nTEST\")\nprint(X_test.shape)\nprint(y_test.shape)\n\n\n\nTRAIN\n(14366, 100)\n(14366,)\n\nVALIDATION\n(3592, 100)\n(3592,)\n\nTEST\n(4490, 100)\n(4490,)\n\n\n\n\n\n\n\nCode\n# checking the imbalance\nsns.countplot(x=y)\nplt.xticks(rotation=45)\nplt.title(\"Class Distribution in CURREL\")\nplt.show()\n\n# adding re-sampling to deal with class imabalance\nsmote = SMOTE(random_state=6600)\nX_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# initiating parameters\nbest_val = 0\nopt_reg = None\nval_scores = {}\nreg_params = [0.0, 0.05, 0.1, 0.2, 0.5, 0.9]\n\nfor r in reg_params:\n    qda_model = QuadraticDiscriminantAnalysis(reg_param=0.2)\n    qda_model.fit(X_train_bal, y_train_bal)\n\n    # getting the predictions\n    y_val_pred = qda_model.predict(X_val)\n    val_score = accuracy_score(y_val, y_val_pred)\n    val_scores[r] = val_score\n\n    # updating best reg value\n    if val_score &gt; best_val:\n        best_val = val_score\n        opt_reg = r\n\nprint(\"\\nOptimal reg_param:\", opt_reg)\nprint(\"Validation accuracy:\", best_val)\n\n# plotting\nplt.plot(val_scores.keys(), val_scores.values(), marker='o')\nplt.title(\"Validation Accuracy vs reg_param\")\nplt.xlabel(\"reg_param\")\nplt.ylabel(\"Validation Accuracy\")\nplt.grid(True)\nplt.show()\n\n\n\nOptimal reg_param: 0.0\nValidation accuracy: 0.6909799554565702\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nopt_reg = 0.2\nqda_model = QuadraticDiscriminantAnalysis(reg_param=opt_reg) # iniating QDA\nqda_model.fit(X_train_bal, y_train_bal)\n\n# getting the predictions\ny_train_pred = qda_model.predict(X_train)\ny_test_pred = qda_model.predict(X_test)\ny_val_pred = qda_model.predict(X_val)\n\n\n\n\n\n\n\nCode\n# classification report\nprint(\"CLASSIFICATION REPORT:\")\nprint(classification_report(y_test, y_test_pred, zero_division=0))\nprint(accuracy_score(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# confusion matrix\nprint(\"CONFUSION MATRIX:\")\nprint(confusion_matrix(y_test, y_test_pred))\nprint(\"-----------------------\")\n\n# ROC curve\nprint(\"ROC CURVES:\")\nclasses = qda_model.classes_ # getting classes\ny_score = qda_model.predict_proba(X_test) # predictions\ny_onehot = label_binarize(y_test, classes=classes)\nfor i, label in enumerate(classes): # plotting ROC for all classes of digits\n    auc = roc_auc_score(y_onehot[:, i], y_score[:, i])\n    display = RocCurveDisplay.from_predictions( # ROC\n        y_true=y_onehot[:, i],\n        y_pred=y_score[:, i],\n        name=f\"Religion {label} vs the rest\",\n        color=\"darkorange\",\n        plot_chance_level=True,\n        despine=True,\n        )\n    _ = display.ax_.set(\n        xlabel=\"False Positive Rate\",\n        ylabel=\"True Positive Rate\"\n    )\nplt.show()\n\n\nCLASSIFICATION REPORT:\n                precision    recall  f1-score   support\n\n      Catholic       0.56      0.64      0.60       815\n     Christian       0.14      0.16      0.15        63\n        Jewish       0.23      0.50      0.32       107\n        Mormon       0.18      0.65      0.29        69\n        Muslim       0.53      0.22      0.31        37\nOther Religion       0.29      0.48      0.36       173\n    Protestant       0.83      0.65      0.73      1777\n  Unaffiliated       0.91      0.82      0.86      1449\n\n      accuracy                           0.68      4490\n     macro avg       0.46      0.52      0.45      4490\n  weighted avg       0.75      0.68      0.71      4490\n\n0.6841870824053452\n-----------------------\nCONFUSION MATRIX:\n[[ 525   18   43   39    0   13  166   11]\n [  14   10    4    1    1    8   22    3]\n [  18    1   54    1    0    5    7   21]\n [  12    0    0   45    0    0   11    1]\n [   6    2    1    0    8   12    6    2]\n [   5    1    8    0    4   83    7   65]\n [ 341   31   71  159    1    6 1160    8]\n [  19    8   51    0    1  159   24 1187]]\n-----------------------\nROC CURVES:"
  }
]